#Notes:as we have two species used in our analysis, for simplicity, this script will just use Parus monticolus as an example.
#This script used for simulating Gradient Forest and computes genomic offset 
#Install the dependencies package
install.packages("gradientForest", repos="http://R-Forge.R-project.org")
rm(list=ls())
library(gradientForest)#version 0.1-24
#Load pop allele frequency
gbt_snp <- read_table("gbt.alfreq", col_names = TRUE)
#Load bio-factor
gbt_env <- read.csv("gbt_env.csv") %>% distinct()
rownames(gbt_env) <- rownames(gbt_snp)#Match row names
#GF analysis
nSites <- dim(gbt_snp)[1]
nSpecs <- dim(gbt_snp)[2]
lev <- floor(log2(nSites*0.368/2))
lev
gf <- gradientForest(cbind(gbt_env,gbt_snp), predictor.vars=colnames(gbt_env), 
                     response.vars=colnames(gbt_snp), ntree = 500,maxLevel = lev, 
                     corr.threshold = 0.5, compact = T, nbin = 201)
gf

#Plot cumulative important
most_important <- names(importance(gf))[1:19]
plot(gf ,plot.type="O",legend = F)
plot(gf, plot.type = "C", imp.vars = most_important,
     show.species = F, common.scale = T)

#Simulate current genetic composition
gbt_current_bio <- read_csv("current_bio.csv") %>% as.data.frame()
imp.vars <- c("bio3","bio18","bio9","bio5","bio19")
Trns_grid <- cbind(gbt_current_bio[,c("long","lat")], predict(gf,gbt_current_bio[,imp.vars]))
PCs <- prcomp(Trns_grid[,imp.vars])
sgn <- sign(PCs$rotation["bio3",])
PCs$rotation <- sweep(PCs$rotation,2,sgn,"*")
PCs$x <- sweep(PCs$x,2,sgn,"*")
a1 <- PCs$x[,1]
a2 <- PCs$x[,2]
a3 <- PCs$x[,3]
r <- a1+a2
g <- -a2
b <- a3+a2-a1
r <- (r-min(r)) / (max(r)-min(r)) * 255
g <- (g-min(g)) / (max(g)-min(g)) * 255
b <- (b-min(b)) / (max(b)-min(b)) * 255
plot(Trns_grid[,c("long","lat")],pch=".", cex=3, asp=1, col=rgb(r,g,b, max = 255))

#Simulate future genetic composition
#Just use 2050-RCP4.5 as an example, all bio-factor values were the mean of 4 GCMs
fut_5045 <- read_csv("fut_5045.csv") %>% as.data.frame()
Trns_grid_5045 <- cbind(fut_5045[,c("long","lat")], predict(gf,fut_5045[,imp.vars]))
##Compute the GV value
euclidean <- function(a, b) sqrt(sum((a - b)^2))#Euclidean distance for genetic offset
df <- data.frame()
for (i in 1:nrow(fut_5045)){
  enc_dist <- euclidean(Trns_grid[i,imp.vars],Trns_grid_5045[i,imp.vars]) %>% as.data.frame()
  df <- rbind(df,enc_dist)
  names(df) <- "GV_5045"
}
gbt_gv_RCP45 <- rbind(fut_5045[,c("long","lat")], df)
#Convert points of average value to raster
gv_RCP45_raster <- gbt_gv_RCP45 %>% rasterFromXYZ(crs="+proj=longlat +datum=WGS84 +no_defs")

